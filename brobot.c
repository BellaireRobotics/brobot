#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  armMotor,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           flappers,      tmotorVex393, openLoop)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port3,           backRight,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           frontLeft,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port7,           arm1,          tmotorVex393, openLoop)
#pragma config(Motor,  port8,           arm2,          tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

#define NORM(n) (127 * n / 10)

/* n must be a range from -10 to 10. */
void forward(int n);
void reverse(int n);
void right(int n);
void left(int n);
void turn_right(int n);
void turn_left(int n);
void arm_up(int n);
void arm_down(int n);
void flapper_in(int n);
void flapper_out(int n);

void pre_auton() {
  bStopTasksBetweenModes = true;
}

task autonomous() {
  Forward(5);
  Sleep(5000);
  Back(5);
  Sleep(5000);
  Right(10);
  Sleep(2000);
  Left(10);
  Sleep(2000);
}

task usercontrol() {
  int X2 = 0, Y1 = 0, X1 = 0, threshold = 15, arm_pos = 0, arm_pos_set = 0;

  while (1) {
    if (abs(vexRT[Ch4]) > threshold || abs(vexRT[Ch4Xmtr2]) > threshold) {
      Y1 = vexRT[Ch4] ? vexRT[Ch4] : vexRT[Ch4Xmtr2];
    } else {
      Y1 = 0;
    }

    if (abs(vexRT[Ch1]) > threshold || abs(vexRT[Ch1Xmtr2]) > threshold) {
      X1 = -vexRT[Ch1] ? -vexRT[Ch1] : -vexRT[Ch1Xmtr2];
    } else {
      X1 = 0;
    }

    if (abs(vexRT[Ch2]) > threshold || abs(vexRT[Ch2Xmtr2]) > threshold) {
      X2 = vexRT[Ch2] ? vexRT[Ch2] : vexRT[Ch2Xmtr2];
    } else {
      X2 = 0;
    }

    motor[frontRight] = Y1 - X2 - X1;
    motor[backRight] =  Y1 - X2 + X1;
    motor[frontLeft] = Y1 + X2 + X1;
    motor[backLeft] =  Y1 + X2 - X1;


    if (vexRT[Btn6U] || vexRT[Btn6UXmtr2]) {
      motor[flappers] = 127;
    } else if (vexRT[Btn6D] || vexRT[Btn6DXmtr2]) {
      motor[flappers] = -127;
    } else {
      motor[flappers] = 0;
    }

    if (vexRT[Btn5U] || vexRT[Btn5UXmtr2]) {
      motor[arm1] = 127;
      motor[arm2] = 127;
      arm_pos_set = 0;
    } else if (vexRT[Btn5D] || vexRT[Btn5DXmtr2]) {
      motor[arm1] = -127;
      motor[arm2] = -127;
      arm_pos_set = 0;
    } else {
      motor[arm1] = 0;
      motor[arm2] = 0;

      if (arm_pos_set == 0) {
        arm_pos = SensorValue[I2C_1];
        arm_pos_set = 1;
      }

      if (SensorValue[I2C_1] > arm_pos) {
        motor[arm1] = 15;
        motor[arm2] = 15;
      } else if (SensorValue[I2C_1] < arm_pos) {
        motor[arm1] = -15;
        motor[arm2] = -15;
      } else {
        motor[arm1] = 0;
        motor[arm2] = 0;
      }
    }

    if (vexRT[Btn7R] && vexRT[Btn8L] || vexRT[Btn7RXmtr2] && vexRT[Btn8LXmtr2]) {
      StartTask(autonomous);

      int i = 0;

      for (i = 0; i < 20; i++) {
        Sleep(1000);
        if (vexRT[Btn7R] && vexRT[Btn8R] || vexRT[Btn7RXmtr2] && vexRT[Btn8RXmtr2]) {
          break;
        }
      }
    }
  }
}

void forward(int n) {
  n = NORM(n);
  motor[frontRight] = -n;
  motor[backRight] = -n;
  motor[frontLeft] = n;
  motor[backLeft] =  n;
}

void reverse(int n) {
  forward(-n);
}

void right(int n) {
  n = NORM(n);
  motor[frontRight] = n;
  motor[backRight] =  -n;
  motor[frontLeft] = -n;
  motor[backLeft] =  n;
}

void left(int n) {
   right(-n);
}

void turn_right(int n) {
  n = NORM(n);
  motor[frontRight] = n;
  motor[backRight] =  n;
  motor[frontLeft] = n;
  motor[backLeft] =  n;
}

void turn_left(int) {
  turn_right(-n);
}

void arm_up(int n) {
  n = NORM(n);
  motor[arm1] = n;
  motor[arm2] = n;
}

void arm_down(int n) {
  arm_up(-n);
}

void flapper_in(int n) {
  n = NORM(n);
  motor[flappers] = n;
}

void flapper_out(int n) {
  flapper_in(-n);
}
